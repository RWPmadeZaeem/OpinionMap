/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/d3-cloud";
exports.ids = ["vendor-chunks/d3-cloud"];
exports.modules = {

/***/ "(ssr)/./node_modules/d3-cloud/index.js":
/*!****************************************!*\
  !*** ./node_modules/d3-cloud/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n// Algorithm due to Jonathan Feinberg, https://s3.amazonaws.com/static.mrfeinberg.com/bv_ch03.pdf\n\nconst dispatch = (__webpack_require__(/*! d3-dispatch */ \"(ssr)/./node_modules/d3-dispatch/src/index.js\").dispatch);\n\nconst RADIANS = Math.PI / 180;\n\nconst SPIRALS = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\n\nconst cw = 1 << 11 >> 5;\nconst ch = 1 << 11;\n\nmodule.exports = function() {\n  var size = [256, 256],\n      text = cloudText,\n      font = cloudFont,\n      fontSize = cloudFontSize,\n      fontStyle = cloudFontNormal,\n      fontWeight = cloudFontNormal,\n      rotate = cloudRotate,\n      padding = cloudPadding,\n      spiral = archimedeanSpiral,\n      words = [],\n      timeInterval = Infinity,\n      event = dispatch(\"word\", \"end\"),\n      timer = null,\n      random = Math.random,\n      cloud = {},\n      canvas = cloudCanvas;\n\n  cloud.canvas = function(_) {\n    return arguments.length ? (canvas = functor(_), cloud) : canvas;\n  };\n\n  cloud.start = function() {\n    var contextAndRatio = getContext(canvas()),\n        board = zeroArray((size[0] >> 5) * size[1]),\n        bounds = null,\n        n = words.length,\n        i = -1,\n        tags = [],\n        data = words.map(function(d, i) {\n          d.text = text.call(this, d, i);\n          d.font = font.call(this, d, i);\n          d.style = fontStyle.call(this, d, i);\n          d.weight = fontWeight.call(this, d, i);\n          d.rotate = rotate.call(this, d, i);\n          d.size = ~~fontSize.call(this, d, i);\n          d.padding = padding.call(this, d, i);\n          return d;\n        }).sort(function(a, b) { return b.size - a.size; });\n\n    if (timer) clearInterval(timer);\n    timer = setInterval(step, 0);\n    step();\n\n    return cloud;\n\n    function step() {\n      var start = Date.now();\n      while (Date.now() - start < timeInterval && ++i < n && timer) {\n        var d = data[i];\n        d.x = (size[0] * (random() + .5)) >> 1;\n        d.y = (size[1] * (random() + .5)) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n          event.call(\"word\", cloud, d);\n          if (bounds) cloudBounds(bounds, d);\n          else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n      if (i >= n) {\n        cloud.stop();\n        event.call(\"end\", cloud, tags, bounds);\n      }\n    }\n  }\n\n  cloud.stop = function() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n    for (const d of words) {\n      delete d.sprite;\n    }\n    return cloud;\n  };\n\n  function getContext(canvas) {\n    const context = canvas.getContext(\"2d\", {willReadFrequently: true});\n\n    canvas.width = canvas.height = 1;\n    const ratio = Math.sqrt(context.getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n\n    context.fillStyle = context.strokeStyle = \"red\";\n\n    return {context, ratio};\n  }\n\n  function place(board, tag, bounds) {\n    var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],\n        startX = tag.x,\n        startY = tag.y,\n        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n        s = spiral(size),\n        dt = random() < .5 ? 1 : -1,\n        t = -dt,\n        dxdy,\n        dx,\n        dy;\n\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||\n          tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || collideRects(tag, bounds)) {\n        if (!cloudCollide(tag, board, size[0])) {\n          var sprite = tag.sprite,\n              w = tag.width >> 5,\n              sw = size[0] >> 5,\n              lx = tag.x - (w << 4),\n              sx = lx & 0x7f,\n              msx = 32 - sx,\n              h = tag.y1 - tag.y0,\n              x = (tag.y + tag.y0) * sw + (lx >> 5),\n              last;\n          for (var j = 0; j < h; j++) {\n            last = 0;\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  cloud.timeInterval = function(_) {\n    return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;\n  };\n\n  cloud.words = function(_) {\n    return arguments.length ? (words = _, cloud) : words;\n  };\n\n  cloud.size = function(_) {\n    return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;\n  };\n\n  cloud.font = function(_) {\n    return arguments.length ? (font = functor(_), cloud) : font;\n  };\n\n  cloud.fontStyle = function(_) {\n    return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;\n  };\n\n  cloud.fontWeight = function(_) {\n    return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;\n  };\n\n  cloud.rotate = function(_) {\n    return arguments.length ? (rotate = functor(_), cloud) : rotate;\n  };\n\n  cloud.text = function(_) {\n    return arguments.length ? (text = functor(_), cloud) : text;\n  };\n\n  cloud.spiral = function(_) {\n    return arguments.length ? (spiral = SPIRALS[_] || _, cloud) : spiral;\n  };\n\n  cloud.fontSize = function(_) {\n    return arguments.length ? (fontSize = functor(_), cloud) : fontSize;\n  };\n\n  cloud.padding = function(_) {\n    return arguments.length ? (padding = functor(_), cloud) : padding;\n  };\n\n  cloud.random = function(_) {\n    return arguments.length ? (random = _, cloud) : random;\n  };\n\n  cloud.on = function() {\n    var value = event.on.apply(event, arguments);\n    return value === event ? cloud : value;\n  };\n\n  return cloud;\n};\n\nfunction cloudText(d) {\n  return d.text;\n}\n\nfunction cloudFont() {\n  return \"serif\";\n}\n\nfunction cloudFontNormal() {\n  return \"normal\";\n}\n\nfunction cloudFontSize(d) {\n  return Math.sqrt(d.value);\n}\n\nfunction cloudRotate() {\n  return (~~(random() * 6) - 3) * 30;\n}\n\nfunction cloudPadding() {\n  return 1;\n}\n\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n      ratio = contextAndRatio.ratio;\n\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n      y = 0,\n      maxh = 0,\n      n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + \" \" + d.weight + \" \" + ~~((d.size + 1) / ratio) + \"px \" + d.font;\n    const metrics = c.measureText(d.text);\n    const anchor = -Math.floor(metrics.width / 2);\n    let w = (metrics.width + 1) * ratio;\n    let h = d.size << 1;\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * RADIANS),\n          cr = Math.cos(d.rotate * RADIANS),\n          wcr = w * cr,\n          wsr = w * sr,\n          hcr = h * cr,\n          hsr = h * sr;\n      w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = (w + 0x1f) >> 5 << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= (cw << 5)) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * RADIANS);\n    c.fillText(d.text, anchor, 0);\n    if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, anchor, 0);\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n      sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n        w32 = w >> 5,\n        h = d.y1 - d.y0;\n    // Zero the buffer\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n        seenRow = -1;\n    for (var j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n            m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;\n      else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n      w = tag.width >> 5,\n      lx = tag.x - (w << 4),\n      sx = lx & 0x7f,\n      msx = 32 - sx,\n      h = tag.y1 - tag.y0,\n      x = (tag.y + tag.y0) * sw + (lx >> 5),\n      last;\n  for (var j = 0; j < h; j++) {\n    last = 0;\n    for (var i = 0; i <= w; i++) {\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))\n          & board[x + i]) return true;\n    }\n    x += sw;\n  }\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n      b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\n\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function(t) {\n    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  var dy = 4,\n      dx = dy * size[0] / size[1],\n      x = 0,\n      y = 0;\n  return function(t) {\n    var sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n      case 0:  x += dx; break;\n      case 1:  y += dy; break;\n      case 2:  x -= dx; break;\n      default: y -= dy; break;\n    }\n    return [x, y];\n  };\n}\n\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  var a = [],\n      i = -1;\n  while (++i < n) a[i] = 0;\n  return a;\n}\n\nfunction cloudCanvas() {\n  return document.createElement(\"canvas\");\n}\n\nfunction functor(d) {\n  return typeof d === \"function\" ? d : function() { return d; };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZDMtY2xvdWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSxpQkFBaUIsa0dBQStCOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdCQUF3Qix5QkFBeUI7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZCQUE2QixHQUFHLDZCQUE2QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHlCQUF5Qjs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0Esc0JBQXNCLFdBQVcsR0FBRyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9kMy1jbG91ZC9pbmRleC5qcz9hYmRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdvcmQgY2xvdWQgbGF5b3V0IGJ5IEphc29uIERhdmllcywgaHR0cHM6Ly93d3cuamFzb25kYXZpZXMuY29tL3dvcmRjbG91ZC9cbi8vIEFsZ29yaXRobSBkdWUgdG8gSm9uYXRoYW4gRmVpbmJlcmcsIGh0dHBzOi8vczMuYW1hem9uYXdzLmNvbS9zdGF0aWMubXJmZWluYmVyZy5jb20vYnZfY2gwMy5wZGZcblxuY29uc3QgZGlzcGF0Y2ggPSByZXF1aXJlKFwiZDMtZGlzcGF0Y2hcIikuZGlzcGF0Y2g7XG5cbmNvbnN0IFJBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuXG5jb25zdCBTUElSQUxTID0ge1xuICBhcmNoaW1lZGVhbjogYXJjaGltZWRlYW5TcGlyYWwsXG4gIHJlY3Rhbmd1bGFyOiByZWN0YW5ndWxhclNwaXJhbFxufTtcblxuY29uc3QgY3cgPSAxIDw8IDExID4+IDU7XG5jb25zdCBjaCA9IDEgPDwgMTE7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gWzI1NiwgMjU2XSxcbiAgICAgIHRleHQgPSBjbG91ZFRleHQsXG4gICAgICBmb250ID0gY2xvdWRGb250LFxuICAgICAgZm9udFNpemUgPSBjbG91ZEZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlID0gY2xvdWRGb250Tm9ybWFsLFxuICAgICAgZm9udFdlaWdodCA9IGNsb3VkRm9udE5vcm1hbCxcbiAgICAgIHJvdGF0ZSA9IGNsb3VkUm90YXRlLFxuICAgICAgcGFkZGluZyA9IGNsb3VkUGFkZGluZyxcbiAgICAgIHNwaXJhbCA9IGFyY2hpbWVkZWFuU3BpcmFsLFxuICAgICAgd29yZHMgPSBbXSxcbiAgICAgIHRpbWVJbnRlcnZhbCA9IEluZmluaXR5LFxuICAgICAgZXZlbnQgPSBkaXNwYXRjaChcIndvcmRcIiwgXCJlbmRcIiksXG4gICAgICB0aW1lciA9IG51bGwsXG4gICAgICByYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgIGNsb3VkID0ge30sXG4gICAgICBjYW52YXMgPSBjbG91ZENhbnZhcztcblxuICBjbG91ZC5jYW52YXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2FudmFzID0gZnVuY3RvcihfKSwgY2xvdWQpIDogY2FudmFzO1xuICB9O1xuXG4gIGNsb3VkLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRleHRBbmRSYXRpbyA9IGdldENvbnRleHQoY2FudmFzKCkpLFxuICAgICAgICBib2FyZCA9IHplcm9BcnJheSgoc2l6ZVswXSA+PiA1KSAqIHNpemVbMV0pLFxuICAgICAgICBib3VuZHMgPSBudWxsLFxuICAgICAgICBuID0gd29yZHMubGVuZ3RoLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIHRhZ3MgPSBbXSxcbiAgICAgICAgZGF0YSA9IHdvcmRzLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgZC50ZXh0ID0gdGV4dC5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgIGQuZm9udCA9IGZvbnQuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICBkLnN0eWxlID0gZm9udFN0eWxlLmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgZC53ZWlnaHQgPSBmb250V2VpZ2h0LmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgZC5yb3RhdGUgPSByb3RhdGUuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICBkLnNpemUgPSB+fmZvbnRTaXplLmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgZC5wYWRkaW5nID0gcGFkZGluZy5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGIuc2l6ZSAtIGEuc2l6ZTsgfSk7XG5cbiAgICBpZiAodGltZXIpIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoc3RlcCwgMCk7XG4gICAgc3RlcCgpO1xuXG4gICAgcmV0dXJuIGNsb3VkO1xuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0IDwgdGltZUludGVydmFsICYmICsraSA8IG4gJiYgdGltZXIpIHtcbiAgICAgICAgdmFyIGQgPSBkYXRhW2ldO1xuICAgICAgICBkLnggPSAoc2l6ZVswXSAqIChyYW5kb20oKSArIC41KSkgPj4gMTtcbiAgICAgICAgZC55ID0gKHNpemVbMV0gKiAocmFuZG9tKCkgKyAuNSkpID4+IDE7XG4gICAgICAgIGNsb3VkU3ByaXRlKGNvbnRleHRBbmRSYXRpbywgZCwgZGF0YSwgaSk7XG4gICAgICAgIGlmIChkLmhhc1RleHQgJiYgcGxhY2UoYm9hcmQsIGQsIGJvdW5kcykpIHtcbiAgICAgICAgICB0YWdzLnB1c2goZCk7XG4gICAgICAgICAgZXZlbnQuY2FsbChcIndvcmRcIiwgY2xvdWQsIGQpO1xuICAgICAgICAgIGlmIChib3VuZHMpIGNsb3VkQm91bmRzKGJvdW5kcywgZCk7XG4gICAgICAgICAgZWxzZSBib3VuZHMgPSBbe3g6IGQueCArIGQueDAsIHk6IGQueSArIGQueTB9LCB7eDogZC54ICsgZC54MSwgeTogZC55ICsgZC55MX1dO1xuICAgICAgICAgIC8vIFRlbXBvcmFyeSBoYWNrXG4gICAgICAgICAgZC54IC09IHNpemVbMF0gPj4gMTtcbiAgICAgICAgICBkLnkgLT0gc2l6ZVsxXSA+PiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA+PSBuKSB7XG4gICAgICAgIGNsb3VkLnN0b3AoKTtcbiAgICAgICAgZXZlbnQuY2FsbChcImVuZFwiLCBjbG91ZCwgdGFncywgYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbG91ZC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkIG9mIHdvcmRzKSB7XG4gICAgICBkZWxldGUgZC5zcHJpdGU7XG4gICAgfVxuICAgIHJldHVybiBjbG91ZDtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHt3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWV9KTtcblxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIGNvbnN0IHJhdGlvID0gTWF0aC5zcXJ0KGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGEubGVuZ3RoID4+IDIpO1xuICAgIGNhbnZhcy53aWR0aCA9IChjdyA8PCA1KSAvIHJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjaCAvIHJhdGlvO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcblxuICAgIHJldHVybiB7Y29udGV4dCwgcmF0aW99O1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2UoYm9hcmQsIHRhZywgYm91bmRzKSB7XG4gICAgdmFyIHBlcmltZXRlciA9IFt7eDogMCwgeTogMH0sIHt4OiBzaXplWzBdLCB5OiBzaXplWzFdfV0sXG4gICAgICAgIHN0YXJ0WCA9IHRhZy54LFxuICAgICAgICBzdGFydFkgPSB0YWcueSxcbiAgICAgICAgbWF4RGVsdGEgPSBNYXRoLnNxcnQoc2l6ZVswXSAqIHNpemVbMF0gKyBzaXplWzFdICogc2l6ZVsxXSksXG4gICAgICAgIHMgPSBzcGlyYWwoc2l6ZSksXG4gICAgICAgIGR0ID0gcmFuZG9tKCkgPCAuNSA/IDEgOiAtMSxcbiAgICAgICAgdCA9IC1kdCxcbiAgICAgICAgZHhkeSxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGR4ZHkgPSBzKHQgKz0gZHQpKSB7XG4gICAgICBkeCA9IH5+ZHhkeVswXTtcbiAgICAgIGR5ID0gfn5keGR5WzFdO1xuXG4gICAgICBpZiAoTWF0aC5taW4oTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpID49IG1heERlbHRhKSBicmVhaztcblxuICAgICAgdGFnLnggPSBzdGFydFggKyBkeDtcbiAgICAgIHRhZy55ID0gc3RhcnRZICsgZHk7XG5cbiAgICAgIGlmICh0YWcueCArIHRhZy54MCA8IDAgfHwgdGFnLnkgKyB0YWcueTAgPCAwIHx8XG4gICAgICAgICAgdGFnLnggKyB0YWcueDEgPiBzaXplWzBdIHx8IHRhZy55ICsgdGFnLnkxID4gc2l6ZVsxXSkgY29udGludWU7XG4gICAgICAvLyBUT0RPIG9ubHkgY2hlY2sgZm9yIGNvbGxpc2lvbnMgd2l0aGluIGN1cnJlbnQgYm91bmRzLlxuICAgICAgaWYgKCFib3VuZHMgfHwgY29sbGlkZVJlY3RzKHRhZywgYm91bmRzKSkge1xuICAgICAgICBpZiAoIWNsb3VkQ29sbGlkZSh0YWcsIGJvYXJkLCBzaXplWzBdKSkge1xuICAgICAgICAgIHZhciBzcHJpdGUgPSB0YWcuc3ByaXRlLFxuICAgICAgICAgICAgICB3ID0gdGFnLndpZHRoID4+IDUsXG4gICAgICAgICAgICAgIHN3ID0gc2l6ZVswXSA+PiA1LFxuICAgICAgICAgICAgICBseCA9IHRhZy54IC0gKHcgPDwgNCksXG4gICAgICAgICAgICAgIHN4ID0gbHggJiAweDdmLFxuICAgICAgICAgICAgICBtc3ggPSAzMiAtIHN4LFxuICAgICAgICAgICAgICBoID0gdGFnLnkxIC0gdGFnLnkwLFxuICAgICAgICAgICAgICB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLFxuICAgICAgICAgICAgICBsYXN0O1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgICAgICBsYXN0ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHc7IGkrKykge1xuICAgICAgICAgICAgICBib2FyZFt4ICsgaV0gfD0gKGxhc3QgPDwgbXN4KSB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCArPSBzdztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2xvdWQudGltZUludGVydmFsID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpbWVJbnRlcnZhbCA9IF8gPT0gbnVsbCA/IEluZmluaXR5IDogXywgY2xvdWQpIDogdGltZUludGVydmFsO1xuICB9O1xuXG4gIGNsb3VkLndvcmRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdvcmRzID0gXywgY2xvdWQpIDogd29yZHM7XG4gIH07XG5cbiAgY2xvdWQuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gWytfWzBdLCArX1sxXV0sIGNsb3VkKSA6IHNpemU7XG4gIH07XG5cbiAgY2xvdWQuZm9udCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmb250ID0gZnVuY3RvcihfKSwgY2xvdWQpIDogZm9udDtcbiAgfTtcblxuICBjbG91ZC5mb250U3R5bGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZm9udFN0eWxlID0gZnVuY3RvcihfKSwgY2xvdWQpIDogZm9udFN0eWxlO1xuICB9O1xuXG4gIGNsb3VkLmZvbnRXZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZm9udFdlaWdodCA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IGZvbnRXZWlnaHQ7XG4gIH07XG5cbiAgY2xvdWQucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdGF0ZSA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IHJvdGF0ZTtcbiAgfTtcblxuICBjbG91ZC50ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRleHQgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiB0ZXh0O1xuICB9O1xuXG4gIGNsb3VkLnNwaXJhbCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzcGlyYWwgPSBTUElSQUxTW19dIHx8IF8sIGNsb3VkKSA6IHNwaXJhbDtcbiAgfTtcblxuICBjbG91ZC5mb250U2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmb250U2l6ZSA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IGZvbnRTaXplO1xuICB9O1xuXG4gIGNsb3VkLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZyA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IHBhZGRpbmc7XG4gIH07XG5cbiAgY2xvdWQucmFuZG9tID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmRvbSA9IF8sIGNsb3VkKSA6IHJhbmRvbTtcbiAgfTtcblxuICBjbG91ZC5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGV2ZW50Lm9uLmFwcGx5KGV2ZW50LCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gZXZlbnQgPyBjbG91ZCA6IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBjbG91ZDtcbn07XG5cbmZ1bmN0aW9uIGNsb3VkVGV4dChkKSB7XG4gIHJldHVybiBkLnRleHQ7XG59XG5cbmZ1bmN0aW9uIGNsb3VkRm9udCgpIHtcbiAgcmV0dXJuIFwic2VyaWZcIjtcbn1cblxuZnVuY3Rpb24gY2xvdWRGb250Tm9ybWFsKCkge1xuICByZXR1cm4gXCJub3JtYWxcIjtcbn1cblxuZnVuY3Rpb24gY2xvdWRGb250U2l6ZShkKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZC52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGNsb3VkUm90YXRlKCkge1xuICByZXR1cm4gKH5+KHJhbmRvbSgpICogNikgLSAzKSAqIDMwO1xufVxuXG5mdW5jdGlvbiBjbG91ZFBhZGRpbmcoKSB7XG4gIHJldHVybiAxO1xufVxuXG4vLyBGZXRjaGVzIGEgbW9ub2Nocm9tZSBzcHJpdGUgYml0bWFwIGZvciB0aGUgc3BlY2lmaWVkIHRleHQuXG4vLyBMb2FkIGluIGJhdGNoZXMgZm9yIHNwZWVkLlxuZnVuY3Rpb24gY2xvdWRTcHJpdGUoY29udGV4dEFuZFJhdGlvLCBkLCBkYXRhLCBkaSkge1xuICBpZiAoZC5zcHJpdGUpIHJldHVybjtcbiAgdmFyIGMgPSBjb250ZXh0QW5kUmF0aW8uY29udGV4dCxcbiAgICAgIHJhdGlvID0gY29udGV4dEFuZFJhdGlvLnJhdGlvO1xuXG4gIGMuY2xlYXJSZWN0KDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKTtcbiAgdmFyIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBtYXhoID0gMCxcbiAgICAgIG4gPSBkYXRhLmxlbmd0aDtcbiAgLS1kaTtcbiAgd2hpbGUgKCsrZGkgPCBuKSB7XG4gICAgZCA9IGRhdGFbZGldO1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuZm9udCA9IGQuc3R5bGUgKyBcIiBcIiArIGQud2VpZ2h0ICsgXCIgXCIgKyB+figoZC5zaXplICsgMSkgLyByYXRpbykgKyBcInB4IFwiICsgZC5mb250O1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjLm1lYXN1cmVUZXh0KGQudGV4dCk7XG4gICAgY29uc3QgYW5jaG9yID0gLU1hdGguZmxvb3IobWV0cmljcy53aWR0aCAvIDIpO1xuICAgIGxldCB3ID0gKG1ldHJpY3Mud2lkdGggKyAxKSAqIHJhdGlvO1xuICAgIGxldCBoID0gZC5zaXplIDw8IDE7XG4gICAgaWYgKGQucm90YXRlKSB7XG4gICAgICB2YXIgc3IgPSBNYXRoLnNpbihkLnJvdGF0ZSAqIFJBRElBTlMpLFxuICAgICAgICAgIGNyID0gTWF0aC5jb3MoZC5yb3RhdGUgKiBSQURJQU5TKSxcbiAgICAgICAgICB3Y3IgPSB3ICogY3IsXG4gICAgICAgICAgd3NyID0gdyAqIHNyLFxuICAgICAgICAgIGhjciA9IGggKiBjcixcbiAgICAgICAgICBoc3IgPSBoICogc3I7XG4gICAgICB3ID0gKE1hdGgubWF4KE1hdGguYWJzKHdjciArIGhzciksIE1hdGguYWJzKHdjciAtIGhzcikpICsgMHgxZikgPj4gNSA8PCA1O1xuICAgICAgaCA9IH5+TWF0aC5tYXgoTWF0aC5hYnMod3NyICsgaGNyKSwgTWF0aC5hYnMod3NyIC0gaGNyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSAodyArIDB4MWYpID4+IDUgPDwgNTtcbiAgICB9XG4gICAgaWYgKGggPiBtYXhoKSBtYXhoID0gaDtcbiAgICBpZiAoeCArIHcgPj0gKGN3IDw8IDUpKSB7XG4gICAgICB4ID0gMDtcbiAgICAgIHkgKz0gbWF4aDtcbiAgICAgIG1heGggPSAwO1xuICAgIH1cbiAgICBpZiAoeSArIGggPj0gY2gpIGJyZWFrO1xuICAgIGMudHJhbnNsYXRlKCh4ICsgKHcgPj4gMSkpIC8gcmF0aW8sICh5ICsgKGggPj4gMSkpIC8gcmF0aW8pO1xuICAgIGlmIChkLnJvdGF0ZSkgYy5yb3RhdGUoZC5yb3RhdGUgKiBSQURJQU5TKTtcbiAgICBjLmZpbGxUZXh0KGQudGV4dCwgYW5jaG9yLCAwKTtcbiAgICBpZiAoZC5wYWRkaW5nKSBjLmxpbmVXaWR0aCA9IDIgKiBkLnBhZGRpbmcsIGMuc3Ryb2tlVGV4dChkLnRleHQsIGFuY2hvciwgMCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gICAgZC53aWR0aCA9IHc7XG4gICAgZC5oZWlnaHQgPSBoO1xuICAgIGQueG9mZiA9IHg7XG4gICAgZC55b2ZmID0geTtcbiAgICBkLngxID0gdyA+PiAxO1xuICAgIGQueTEgPSBoID4+IDE7XG4gICAgZC54MCA9IC1kLngxO1xuICAgIGQueTAgPSAtZC55MTtcbiAgICBkLmhhc1RleHQgPSB0cnVlO1xuICAgIHggKz0gdztcbiAgfVxuICB2YXIgcGl4ZWxzID0gYy5nZXRJbWFnZURhdGEoMCwgMCwgKGN3IDw8IDUpIC8gcmF0aW8sIGNoIC8gcmF0aW8pLmRhdGEsXG4gICAgICBzcHJpdGUgPSBbXTtcbiAgd2hpbGUgKC0tZGkgPj0gMCkge1xuICAgIGQgPSBkYXRhW2RpXTtcbiAgICBpZiAoIWQuaGFzVGV4dCkgY29udGludWU7XG4gICAgdmFyIHcgPSBkLndpZHRoLFxuICAgICAgICB3MzIgPSB3ID4+IDUsXG4gICAgICAgIGggPSBkLnkxIC0gZC55MDtcbiAgICAvLyBaZXJvIHRoZSBidWZmZXJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGggKiB3MzI7IGkrKykgc3ByaXRlW2ldID0gMDtcbiAgICB4ID0gZC54b2ZmO1xuICAgIGlmICh4ID09IG51bGwpIHJldHVybjtcbiAgICB5ID0gZC55b2ZmO1xuICAgIHZhciBzZWVuID0gMCxcbiAgICAgICAgc2VlblJvdyA9IC0xO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICB2YXIgayA9IHczMiAqIGogKyAoaSA+PiA1KSxcbiAgICAgICAgICAgIG0gPSBwaXhlbHNbKCh5ICsgaikgKiAoY3cgPDwgNSkgKyAoeCArIGkpKSA8PCAyXSA/IDEgPDwgKDMxIC0gKGkgJSAzMikpIDogMDtcbiAgICAgICAgc3ByaXRlW2tdIHw9IG07XG4gICAgICAgIHNlZW4gfD0gbTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWVuKSBzZWVuUm93ID0gajtcbiAgICAgIGVsc2Uge1xuICAgICAgICBkLnkwKys7XG4gICAgICAgIGgtLTtcbiAgICAgICAgai0tO1xuICAgICAgICB5Kys7XG4gICAgICB9XG4gICAgfVxuICAgIGQueTEgPSBkLnkwICsgc2VlblJvdztcbiAgICBkLnNwcml0ZSA9IHNwcml0ZS5zbGljZSgwLCAoZC55MSAtIGQueTApICogdzMyKTtcbiAgfVxufVxuXG4vLyBVc2UgbWFzay1iYXNlZCBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuZnVuY3Rpb24gY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHN3KSB7XG4gIHN3ID4+PSA1O1xuICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICAgIHcgPSB0YWcud2lkdGggPj4gNSxcbiAgICAgIGx4ID0gdGFnLnggLSAodyA8PCA0KSxcbiAgICAgIHN4ID0gbHggJiAweDdmLFxuICAgICAgbXN4ID0gMzIgLSBzeCxcbiAgICAgIGggPSB0YWcueTEgLSB0YWcueTAsXG4gICAgICB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLFxuICAgICAgbGFzdDtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICBsYXN0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB3OyBpKyspIHtcbiAgICAgIGlmICgoKGxhc3QgPDwgbXN4KSB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApKVxuICAgICAgICAgICYgYm9hcmRbeCArIGldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeCArPSBzdztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNsb3VkQm91bmRzKGJvdW5kcywgZCkge1xuICB2YXIgYjAgPSBib3VuZHNbMF0sXG4gICAgICBiMSA9IGJvdW5kc1sxXTtcbiAgaWYgKGQueCArIGQueDAgPCBiMC54KSBiMC54ID0gZC54ICsgZC54MDtcbiAgaWYgKGQueSArIGQueTAgPCBiMC55KSBiMC55ID0gZC55ICsgZC55MDtcbiAgaWYgKGQueCArIGQueDEgPiBiMS54KSBiMS54ID0gZC54ICsgZC54MTtcbiAgaWYgKGQueSArIGQueTEgPiBiMS55KSBiMS55ID0gZC55ICsgZC55MTtcbn1cblxuZnVuY3Rpb24gY29sbGlkZVJlY3RzKGEsIGIpIHtcbiAgcmV0dXJuIGEueCArIGEueDEgPiBiWzBdLnggJiYgYS54ICsgYS54MCA8IGJbMV0ueCAmJiBhLnkgKyBhLnkxID4gYlswXS55ICYmIGEueSArIGEueTAgPCBiWzFdLnk7XG59XG5cbmZ1bmN0aW9uIGFyY2hpbWVkZWFuU3BpcmFsKHNpemUpIHtcbiAgdmFyIGUgPSBzaXplWzBdIC8gc2l6ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gW2UgKiAodCAqPSAuMSkgKiBNYXRoLmNvcyh0KSwgdCAqIE1hdGguc2luKHQpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTcGlyYWwoc2l6ZSkge1xuICB2YXIgZHkgPSA0LFxuICAgICAgZHggPSBkeSAqIHNpemVbMF0gLyBzaXplWzFdLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgc2lnbiA9IHQgPCAwID8gLTEgOiAxO1xuICAgIC8vIFNlZSB0cmlhbmd1bGFyIG51bWJlcnM6IFRfbiA9IG4gKiAobiArIDEpIC8gMi5cbiAgICBzd2l0Y2ggKChNYXRoLnNxcnQoMSArIDQgKiBzaWduICogdCkgLSBzaWduKSAmIDMpIHtcbiAgICAgIGNhc2UgMDogIHggKz0gZHg7IGJyZWFrO1xuICAgICAgY2FzZSAxOiAgeSArPSBkeTsgYnJlYWs7XG4gICAgICBjYXNlIDI6ICB4IC09IGR4OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHkgLT0gZHk7IGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gW3gsIHldO1xuICB9O1xufVxuXG4vLyBUT0RPIHJldXNlIGFycmF5cz9cbmZ1bmN0aW9uIHplcm9BcnJheShuKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBuKSBhW2ldID0gMDtcbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNsb3VkQ2FudmFzKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbn1cblxuZnVuY3Rpb24gZnVuY3RvcihkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gXCJmdW5jdGlvblwiID8gZCA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZDsgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/d3-cloud/index.js\n");

/***/ })

};
;